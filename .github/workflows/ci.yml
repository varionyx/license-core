name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read
  pull-requests: read

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Enforce squash-only merge policy (no merge commits in PR branch)
        if: github.event_name == 'pull_request'
        run: |
          git fetch origin ${{ github.event.pull_request.base.ref }}
          MERGE_BASE=$(git merge-base origin/${{ github.event.pull_request.base.ref }} ${{ github.event.pull_request.head.sha }})
          COUNT=$(git rev-list --count --merges "$MERGE_BASE..${{ github.event.pull_request.head.sha }}")
          if [ "$COUNT" -gt 0 ]; then
            echo "::error::PR branch contains $COUNT merge commit(s). Rebase on base branch; use Squash and merge only."
            exit 1
          fi
          echo "No merge commits in PR branch; squash merge policy OK."
      - name: Verify commit signatures (GitHub verification API)
        if: github.event_name == 'push' || github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            let commits = [];

            if (context.eventName === 'pull_request') {
              const prNumber = context.payload.pull_request.number;
              commits = await github.paginate(github.rest.pulls.listCommits, {
                owner, repo, pull_number: prNumber, per_page: 100
              });
            } else {
              const base = context.payload.before;
              const head = context.payload.after || context.sha;
              if (!base || /^0+$/.test(base)) {
                const one = await github.rest.repos.getCommit({ owner, repo, ref: head });
                commits = [one.data];
              } else {
                const cmp = await github.rest.repos.compareCommits({
                  owner, repo, base, head
                });
                commits = cmp.data.commits || [];
              }
            }

            if (commits.length === 0) {
              core.warning('No commits found for signature verification.');
            }

            for (const c of commits) {
              const sha = c.sha;
              const details = await github.rest.repos.getCommit({ owner, repo, ref: sha });
              const verification = details.data.commit && details.data.commit.verification;
              const verified = verification && verification.verified === true;
              if (!verified) {
                const reason = verification ? verification.reason : 'unknown';
                core.setFailed(`Commit ${sha} is not signed/verified. reason=${reason}. license-core requires signed commits.`);
                return;
              }
            }
            core.info(`Verified ${commits.length} signed commit(s).`);
      - name: Verify tag signature (tags only)
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          tag="${GITHUB_REF#refs/tags/}"
          if ! git verify-tag "$tag" 2>/dev/null; then
            status=$(git cat-file tag "$tag" 2>/dev/null | grep -q gpgsig && echo "has_sig" || echo "no_sig")
            if [ "$status" = "no_sig" ]; then
              echo "::error::Tag $tag is not signed. license-core requires signed tags."
              exit 1
            fi
            echo "Tag has signature (crypto verification may require key in keyring)"
          else
            echo "Tag signature verification passed"
          fi
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy
      - name: Reject path or patch in Cargo.toml
        run: |
          if grep -E 'path\s*=' Cargo.toml; then echo "::error::Cargo.toml must not contain path dependency"; exit 1; fi
          if grep -E '\[patch' Cargo.toml; then echo "::error::Cargo.toml must not contain [patch]"; exit 1; fi
      - name: SemVer validation
        run: |
          V=$(grep '^version' Cargo.toml | head -1 | sed 's/.*= *"\(.*\)".*/\1/')
          if ! echo "$V" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+'; then echo "::error::Cargo.toml version must be valid SemVer (X.Y.Z)"; exit 1; fi
      - run: cargo fmt --all -- --check
      - run: cargo clippy --all-targets --all-features -- -D warnings
      - run: cargo test --all
      - name: Supply chain (cargo-deny)
        run: |
          cargo install cargo-deny --locked
          cargo deny check
      - name: Generate SBOM (CycloneDX)
        run: |
          cargo install cargo-cyclonedx --version 0.5.7 --locked
          cargo cyclonedx --format json --override-filename sbom
          # Tool may write sbom.json (stem "sbom"), bom.json, or per-package path; normalize to sbom.json
          if [ -f sbom.json ]; then echo "SBOM at sbom.json"
          elif [ -f bom.json ]; then cp bom.json sbom.json
          else
            F=$(find . -maxdepth 3 \( -name 'sbom.json' -o -name 'bom.json' \) 2>/dev/null | head -1)
            if [ -n "$F" ]; then cp "$F" sbom.json; else echo "::error::SBOM file not found" && ls -laR && exit 1; fi
          fi
      - name: Verify SBOM exists
        run: test -f sbom.json
      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.json
      - name: Security audit (blocking)
        run: |
          cargo install cargo-audit --locked
          cargo audit
